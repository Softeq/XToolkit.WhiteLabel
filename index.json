{
  "articles/configure-android.html": {
    "href": "articles/configure-android.html",
    "title": "Configure Android | XToolkit.WhiteLabel",
    "keywords": "Configure Android Install Install WhiteLabel via NuGet or such as submodule. Setup Configure project Remove MainActivity.cs. Create MainApplication in the root folder and paste the following code: [Application] public class MainApplication : MainApplicationBase { protected MainApplication(IntPtr handle, JniHandleOwnership transfer) : base(handle, transfer) { } protected override IBootstrapper CreateBootstrapper() { return new CustomBootstrapper(); } } Create SplashActivity: [Activity( MainLauncher = true, NoHistory = true)] public class SplashActivity : AppCompatActivity { protected override void OnCreate(Bundle savedInstanceState) { base.OnCreate(savedInstanceState); // Entry point Dependencies.PageNavigationService .For<MainPageViewModel>() .Navigate(); Finish(); } } Configure dependencies Create custom Bootsrapper: public class CustomBootstrapper : DroidBootstrapperBase { protected override void ConfigureIoc(IContainerBuilder builder) { builder.Singleton<JsonSerializer, IJsonSerializer>(); // for saving states // you can register any dependencies here } protected override IList<Assembly> SelectAssemblies() { // for auto-registering ViewModels by Activities return base.SelectAssemblies() .AddItem(GetType().Assembly); } } Create and initialize Activity Create Activity"
  },
  "articles/configure-ios.html": {
    "href": "articles/configure-ios.html",
    "title": "Configure iOS | XToolkit.WhiteLabel",
    "keywords": "Configure iOS Install Install WhiteLabel via NuGet or such as submodule. Setup Configure AppDelegate Copy and replace AppDelegate: [Register(nameof(AppDelegate))] public class AppDelegate : AppDelegateBase { public override bool FinishedLaunching(UIApplication application, NSDictionary launchOptions) { var result = base.FinishedLaunching(application, launchOptions); // Override point for customization after application launch. return result; } protected override IBootstrapper CreateBootstrapper() { return new CustomIosBootstrapper(); } protected override void InitializeNavigation(IContainer container) { var navigationService = container.Resolve<IPageNavigationService>(); navigationService.Initialize(Window.RootViewController); navigationService.For<StartPageViewModel>().Navigate(); } } Configure dependencies Create custom Bootsrapper: public class CustomBootstrapper : IosBootstrapperBase { protected override IList<Assembly> SelectAssemblies() { // for auto-registration ViewModels by ViewControllers return base.SelectAssemblies() .AddItem(GetType().Assembly); } protected override void ConfigureIoc(IContainerBuilder builder) { // you can register any dependencies here } } Create and initialize Storyboard Create Storyboard/ViewController"
  },
  "articles/contributing-documentation.html": {
    "href": "articles/contributing-documentation.html",
    "title": "Contribution to documentation | XToolkit.WhiteLabel",
    "keywords": "Contribution to documentation This document provides an overview of how articles published on https://softeq.github.io/XToolkit.WhiteLabel/ should be formatted. You can actually use this file, itself, as a template when contributing articles. Article Structure We are using DocFX for our documentation, which means that each page needs to have a Markdown layout, which would look something like: # Title ## Sub-title Text --- Edit an existing documentation page, to find out what the current layout looks like. Documentation Syntax The documentation uses DocFX Flavored Markdown, aka DFM. It supports all GitHub Flavored Markdown syntax and compatible with CommonMark. Adding relative links To reference other pages inside the documentation use the following syntax: [Softeq](https://www.softeq.com) Adding images Please add any images for the documentation in the images/ folder. Then you can reference you image like: ![My helpful screenshot](../images/screenshot.png) References Articles [IBindingsOwner](xref:Softeq.XToolkit.Bindings.Abstract.IBindingsOwner) Code System types: <see cref=\"T:UIKit.UIViewController\"/> XToolkit types: <see cref=\"AsyncCommand\"/> Build documentation locally In some cases it might be more comfortable to work locally on updating the documentation pages instead of using the online GitHub editor. This is especially the case when working on bigger changes you’d most likely do on a separate branch and maybe spend multiple days working on. In those cases it might be usefull to be able to generate the site locally, so you can see what your changes look like when rendered in the browser. This means you will have to follow these steps: Make changes in documentation/* folder Build documentation via cd documentation && ./build.sh Open documentation/_site/index.html in browser Summary This style guide is intended to help contributors quickly create new articles for https://softeq.github.io/XToolkit.WhiteLabel/. It includes the most common syntax elements that are used, as well as overall document organization guidance. If you discover mistakes or gaps in this guide, please submit an issue."
  },
  "articles/contributing-workflow.html": {
    "href": "articles/contributing-workflow.html",
    "title": "Contribution Workflow | XToolkit.WhiteLabel",
    "keywords": "Contribution Workflow You can contribute to XToolkit with issues and PRs. Simply filing issues for problems you encounter is a great way to contribute. Contributing implementations is greatly appreciated. Suggested Workflow We use and recommend the following workflow: Create an issue for your work. You can skip this step for trivial changes. Reuse an existing issue on the topic, if there is one. Get agreement from the team and the community that your proposed change is a good one. Clearly state that you are going to take on implementing it, if that's the case. You can request that the issue be assigned to you. Note: The issue filer and the implementer don't have to be the same person. Create a personal fork of the repository on GitHub (if you don't already have one). Create a branch off of master (git checkout -b mybranch). Name the branch so that it clearly communicates your intentions, such as issue-123 or githubhandle-issue. Branches are useful since they isolate your changes from incoming changes from upstream. They also enable you to create multiple PRs from the same fork. Make and commit your changes. Please follow our Commit Messages guidance. Add new tests corresponding to your change, if applicable. Build the repository with your changes. Make sure that the builds are clean. Make sure that the tests are all passing, including your new tests. Create a pull request (PR) against the upstream repository's master branch. Push your changes to your fork on GitHub (if you haven't already). PR - CI Process The XToolkit continuous integration (CI) system will automatically perform the required builds and run tests (including the ones you are expected to run) for PRs. Builds and test runs must be clean. If the CI build fails for any reason, the PR issue will be updated with a link that can be used to determine the cause of the failure. PR Feedback XToolkit team and community members will provide feedback on your change. Community feedback is highly valued. You will often see the absence of team feedback if the community has already provided good review feedback. There are lots of thoughts and approaches for how to efficiently discuss changes. It is best to be clear and explicit with your feedback. Please be patient with people who might not understand the finer details about your approach to feedback. Merging Pull Requests (for contributors with write access) DO use \"Squash and Merge\" by default for individual contributions unless requested by the PR author. Do so, even if the PR contains only one commit. It creates a simpler history than \"Create a Merge Commit\". Reasons that PR authors may request \"Merge and Commit\" may include (but are not limited to): The change is easier to understand as a series of focused commits. Each commit in the series must be buildable so as not to break git bisect. Contributor is using an e-mail address other than the primary GitHub address and wants that preserved in the history. Contributor must be willing to squash the commits manually before acceptance."
  },
  "articles/contributing.html": {
    "href": "articles/contributing.html",
    "title": "Contributing to XToolkit | XToolkit.WhiteLabel",
    "keywords": "Contributing to XToolkit This document describes contribution guidelines that are specific to XToolkit. General contribution guidance is included in this document. Additional guidance is defined in the documents linked below. Contribution Workflow describes the workflow that the team uses for considering and accepting changes. Contribution to Documentation describes guidelines on writing documentation. Coding Style Changes Follow the style used by the C# Coding Guidelines. Also: DO NOT send PRs for style changes. For example, do not send PRs that are focused on changing usage of Int32 to int. DO give priority to the current style of the project or file you're changing even if it diverges from the general guidelines. Pull Requests We are happy to receive Pull Requests adding new features and solving bugs. As for new features, please contact us before doing major work. To ensure you are not working on something that will be rejected due to not fitting into the XToolkit roadmap or ideal of the framework. DO submit all code changes via pull requests (PRs) rather than through a direct commit. PRs will be reviewed and potentially merged by the repo maintainers after a peer review that includes at least one maintainer. DO give PRs short-but-descriptive names (e.g. \"Improve code coverage for System.Console by 10%\", not \"Fix #1234\") DO refer to any relevant issues, and include keywords that automatically close issues when the PR is merged. DO tag any users that should know about and/or review the change. DO ensure each commit successfully builds. The entire PR must pass all tests in the Continuous Integration (CI) system before it'll be merged. DO address PR feedback in an additional commit(s) rather than amending the existing commits, and only rebase/squash them when necessary. This makes it easier for reviewers to track changes. DO assume that \"Squash and Merge\" will be used to merge your commit unless you request otherwise in the PR. DO NOT mix independent, unrelated changes in one PR. Separate real product/test code changes from larger code formatting/dead code removal changes. Separate unrelated fixes into separate PRs, especially if they are in different assemblies. Issues Issues should clearly lay out the problem, platforms experienced on, as well as steps to reproduce the issue. This aids in fixing the issues but also quality assurance, to check that the issue has indeed been fixed. Issues are labelled in the following way depending on its type: bug: The issue is a bug in the product. enhancement: The issue is an enhancement to either an existing feature in the product or to the infrastructure around the development process. documentation: A documentation-related task. c/__: Specifies the component of the task. e/__: Specifies the effort required for the task. p/__: Specifies the priority of the task. Commit Messages Please format commit messages as follows (based on A Note About Git Commit Messages): Summarize change in 50 characters or less Provide more detail after the first line. Leave one blank line below the summary and wrap all lines at 72 characters or less. If the change fixes an issue, leave another blank line after the final paragraph and indicate which issue is fixed in the specific format below. Fix #42 Also do your best to factor commits appropriately, not too large with unrelated things in the same commit, and not too small with the same small change applied N times in N different commits. File Headers The following file header is the used for XToolkit. Please use it for new files: // Developed by Softeq Development Corporation // http://www.softeq.com Also, you can use bash script for set headers: tools/set-headers.sh"
  },
  "articles/create-activity.html": {
    "href": "articles/create-activity.html",
    "title": "Create Activity | XToolkit.WhiteLabel",
    "keywords": "Create Activity First of all, see Navigation Requirements. Steps Create MainPageActivity.cs in Views folder of your Android project: [Activity] public class MainPageActivity : ActivityBase<MainPageViewModel> { protected override void OnCreate(Bundle? savedInstanceState) { base.OnCreate(savedInstanceState); SetContentView(Resource.Layout.my_custom_name_page); } } Create activity_main.xml layout: <?xml version=\"1.0\" encoding=\"utf-8\"?> <RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"> <Button android:id=\"@+id/button1\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"Button\" /> </RelativeLayout> After that, you should be able to navigate to the first page."
  },
  "articles/create-storyboard-viewcontroller.html": {
    "href": "articles/create-storyboard-viewcontroller.html",
    "title": "Create Storyboard ViewController | XToolkit.WhiteLabel",
    "keywords": "Create Storyboard ViewController First of all, see Navigation Requirements. Steps 1. Create Storyboard VS4Mac: Solution folder -> Add -> New File -> iOS -> Storyboard Rider: Solution folder -> Add -> Storyboard Create empty MainPageStoryboard 2. Interface Builder Open storyboard via Interface Builder (IB) VS4Mac: MainPageStoryboard -> Open With -> Xcode Interface Builder Rider: MainPageStoryboard -> Open in Xcode IB: Select Identity Inspector and update next properties: Custom Class > Class to MainPageViewController Identity > Storyboard ID to MainPageViewController More detailed info: Creating a Storyboard with Xcode 3. Setup ViewController public partial class MainPageViewController : ViewControllerBase<MainPageViewModel> { public MainPageViewController(NativeHandle handle) : base(handle) { } } Note You must add this constructor when you want to use storyboard: public MainPageViewController(NativeHandle handle) : base(handle) {} If you load storyboard via code you have to create constructor without parameters. 4. Profit After these steps, you should be able to navigate to MainPageViewModel."
  },
  "articles/create-viewmodel.html": {
    "href": "articles/create-viewmodel.html",
    "title": "Create ViewModel | XToolkit.WhiteLabel",
    "keywords": "Create ViewModel Create class MainPageViewModel in ApplicationName.ViewModels folder. public class MainPageViewModel : ViewModelBase { } Note: Also see Navigation Requirements."
  },
  "articles/developer-guide.html": {
    "href": "articles/developer-guide.html",
    "title": "Developer Guide | XToolkit.WhiteLabel",
    "keywords": "Developer Guide Clone source code git clone https://github.com/Softeq/XToolkit.WhiteLabel.git Building the repository Open the main solution XToolkit.sln via Visual Studio for Mac or Visual Studio IDE or Rider; Restore NuGet packages; For build Android project: Change build configuration to Debug.Droid/AnyCPU Set Playground.Droid as startup project For build iOS project: Change build configuration to Debug.iOS/iPhoneSimulator Set Playground.iOS as startup project For build Xamarin.Forms projects: Android: Playground.Forms.Droid iOS: Playground.Forms.iOS"
  },
  "articles/getting-started.html": {
    "href": "articles/getting-started.html",
    "title": "Getting Started | XToolkit.WhiteLabel",
    "keywords": "Getting Started Before starting you should create three projects: ApplicationName (should be .NET6+ project) which will include your shared ViewModels ApplicationName.iOS ApplicationName.Droid Configuration Configure iOS Configure Android Configuration shared logic Create ViewModel More Create BottomTabs navigation (see Playground) Create dialogs (see Playground)"
  },
  "articles/how-to/create-ios-collection-view.html": {
    "href": "articles/how-to/create-ios-collection-view.html",
    "title": "Create iOS CollectionView | XToolkit.WhiteLabel",
    "keywords": "Create iOS CollectionView This page actual for WhiteLabel v2.0.0-beta2+ Create empty CollectionViewCell Add inheritance of BindableCollectionViewCell<TItem> public partial class ItemViewCell : BindableCollectionViewCell<ItemViewModel> { public static readonly NSString Key = new NSString(nameof(ItemViewCell)); public static readonly UINib Nib; static ItemViewCell() => Nib = UINib.FromName(Key, NSBundle.MainBundle); protected ItemViewCell(IntPtr handle) : base(handle) { } public override void SetBindings() { } } Add UICollectionView to your Storyboard; Setup UICollectionView: CollectionView.RegisterNibForCell(ItemViewCell.Nib, ItemViewCell.Key); CollectionView.DataSource = new BindableCollectionViewSource<ItemViewModel, ItemViewCell>(ViewModel.Items); Handle item clicks // ... CollectionView.Delegate = new BindableUICollectionViewDelegateFlowLayout(); CollectionView.DataSource = new BindableCollectionViewSource<ItemViewModel, ItemViewCell>(ViewModel.Items) { ItemClick = ViewModel.SelectItemCommand }; Bind SelectionItem // TODO: Groups // TODO:"
  },
  "articles/how-to/create-ios-custom-view.html": {
    "href": "articles/how-to/create-ios-custom-view.html",
    "title": "Create iOS Custom View | XToolkit.WhiteLabel",
    "keywords": "Create iOS Custom View How to create custom view via VS for Mac: Approaches 1. ViewCell Create Table/CollectionViewCell Change base class to the CustomViewBase Remove ..Cell.xib Create new view (xib) with the same name (use freeform size) Attach new xib to the custom view (as File's Owner Class) 2. xib Create new view (xib) (use freeform size) Create empty class with attribute [Register(\"MyCustomView\")] Change base class to the CustomViewBase Restart Xcode if opened Attach new xib to the custom view (as File's Owner Class)"
  },
  "articles/how-to/index.html": {
    "href": "articles/how-to/index.html",
    "title": "How to | XToolkit.WhiteLabel",
    "keywords": "How to In this section you can find/add materials about how to do something with XToolkit. We already added some articles that you can see on the menu on the left."
  },
  "articles/manifesto.html": {
    "href": "articles/manifesto.html",
    "title": "XToolkit Manifesto | XToolkit.WhiteLabel",
    "keywords": "XToolkit Manifesto Structure XToolkit contains boilerplate features that you need in every Xamarin project, like MVVM, Navigation, DI. Also, it has additional components like Permissions, commonly used ViewModels, simple ImagePicker, Push-Notifications and others. Contribution If you want to add something to the XToolkit follow the checklist below: [ ] It’s a very common feature for every Xamarin project; [ ] It’s a fix of the existing functionality; Also, see Contributing to XToolkit Philosophy Write what you need and no more, but when you write it, do it right. Avoid implementing features you don’t need. You can’t design a feature without knowing what the constraints are. Implementing features \"for completeness\" results in unused code that is expensive to maintain, learn about, document, test, etc. When you do implement a feature, implement it the right way. Avoid workarounds. Workarounds merely kick the problem further down the road, but at a higher cost: someone will have to relearn the problem, figure out the workaround and how to dismantle it (and all the places that now use it), and implement the feature. It’s much better to take longer to fix a problem properly than to be the one who fixes everything quickly but in a way that will require cleaning up later. Avoid complecting (braiding multiple concepts together) Each API should be self-contained and should not know about other features. Interleaving concepts leads to complexity. Solve real problems by literally solving a real problem Where possible, especially for new features, you should partner with a real customer who wants that feature and is willing to help you test it. Only by actually using a feature in the real world can we truly be confident that a feature is ready for prime time. Listen to their feedback, too. If your first customer is saying that your feature doesn’t actually solve their use case completely, don’t dismiss their concerns as esoteric. Often, what seems like the problem when you start a project turns out to be a trivial concern compared to the real issues faced by real developers."
  },
  "articles/nuget-release-process.html": {
    "href": "articles/nuget-release-process.html",
    "title": "NuGet Release Process | XToolkit.WhiteLabel",
    "keywords": "NuGet Release Process Development Internal members: Checkout from master External members: Clone repository Create PR to the master branch Release XToolkit components Create release/beta4 branch Compare changes (last tag <- master): Update all nuget/*.nuspec (metadata * dependencies) Add changes about components versions to the Doc: NuGet releases Push release/beta4 branch to the GitHub Create PR to master branch [New beta version 4] Check CI validations & PR reviews (Azure Pipelines will automatically build packages) After CI builds manual release will be available (release artifacts) Manually run releases for selected components (Azure DevOps) (will be published to NuGet) Merge release/<version> branch to the master Create tag (for examplev2.0.0-beta4) New milestone Open Milestones Rename vNext milestone to v2 beta N, with text: [ All issues related to release v2.0 beta N of the WhiteLabel and components. ] Close v2 beta N milestone Create a new vNext milestone, with text: [ All issues related to release a future version of the WhiteLabel and components. ] GitHub release Create new Github WL Release (based on previews with new version tag) Update README Update README.md Create new PR to master branch Update Documentation Checkout to master branch Make changes in documentation/* folder Build documentation via cd documentation && ./build.sh Publish _site folder to gh-pages branch"
  },
  "articles/practices/android-res-naming.html": {
    "href": "articles/practices/android-res-naming.html",
    "title": "Android Resources Naming Convention | XToolkit.WhiteLabel",
    "keywords": "Android Resources Naming Convention Resource files Resources file names are written in lowercase_underscore. Drawable files Naming conventions for drawables: Asset Type Prefix Example Action bar ab_ ab_stacked.9.png Button btn_ btn_send_pressed.9.png Dialog dialog_ dialog_top.9.png Divider divider_ divider_horizontal.9.png Icon ic_ ic_star.png Menu menu_ menu_submenu_bg.9.png Notification notification_ notification_bg.9.png Tabs tab_ tab_pressed.9.png Naming conventions for icons (taken from Android iconography guidelines): Asset Type Prefix Example Icons ic_ ic_star.png Launcher icons ic_launcher ic_launcher_calendar.png Menu icons and Action Bar icons ic_menu ic_menu_archive.png Status bar icons ic_notify ic_notify_msg.png Tab icons ic_tab ic_tab_recent.png Dialog icons ic_dialog ic_dialog_info.png Naming conventions for selector states: State Suffix Example Normal _normal btn_order_normal.9.png Pressed _pressed btn_order_pressed.9.png Focused _focused btn_order_focused.9.png Disabled _disabled btn_order_disabled.9.png Selected _selected btn_order_selected.9.png Layout files Layout files should match the name of the Android components that they are intended for but moving the top level component name to the beginning. For example, if we are creating a layout for the SignInActivity, the name of the layout file should be activity_sign_in.xml. Component Prefix Class Name Layout Name Activity activity_ MainPageActivity activity_main.xml Fragment fragment_ DetailsPageFragment fragment_details.xml Dialog dialog_ NewItemPageDialogFragment dialog_new_item.xml AdapterView item item_ PersonViewHolder item_person.xml Custom view layout view_ ProfileAvatarView view_profile_avatar.xml Partial layout partial_ --- partial_stats_bar.xml A slightly different case is when we are creating a layout that is going to be inflated by an Adapter, e.g to populate a ListView. In this case, the name of the layout should start with item_. Note that there are cases where these rules will not be possible to apply. For example, when creating layout files that are intended to be part of other layouts. In this case you should use the prefix partial_. Menu files Similar to layout files, menu files should match the name of the component. For example, if we are defining a menu file that is going to be used in the UserActivity, then the name of the file should be activity_user.xml A good practice is to not include the word menu as part of the name because these files are already located in the menu directory. Values files Resource files in the values folder should be plural: File Description strings.xml Strings colors.xml Colors dimens.xml Sizes attrs.xml Custom attributes themes.xml Theme & ThemeOverlay styles.xml Widget styles shape.xml ShapeAppearance motion.xml Animations styles IDs Resource IDs and names are written in lowercase_underscore. Naming pattern: @+id/<module>_<layout>_<element_name>_<element_type> Sample Description @+id/activity_main_lst Any List data from MainPageActivity. @+id/fragment_details_name_txt EditText for Name from DetailsPageFragment. @+id/dialog_new_item_save_btn Button for Save from NewItemDialog. @+id/item_person_name_lbl TextView for Name Person from list item. @+id/notifications_activity_settings_camera_cb CheckBox for Camera from Settings page from Notifications module. Common controls prefix mapping: Prefix Controls btn Button, ImageButton label TextView input EditText list ListView, RecyclerView img ImageView For other controls use the short form: Prefix Controls cb CheckBox ll LinearLayout rl RelativeLayout pb ProgressBar"
  },
  "articles/practices/index.html": {
    "href": "articles/practices/index.html",
    "title": "Practices | XToolkit.WhiteLabel",
    "keywords": "Practices In this section, you can find/add materials about practices that we follow for developing. We already added some articles that you can see on the menu on the left."
  },
  "articles/practices/unit-tests.html": {
    "href": "articles/practices/unit-tests.html",
    "title": "Unit Tests | XToolkit.WhiteLabel",
    "keywords": "Unit Tests Unit testing is a great idea. It provides for code coverage, is a resource for documentation, and it provides a vehicle for good design. Naming your tests The name of the test should tell you what the test is doing without you having to read every line of code to figure it out. It should explain the prerequisites. It should explain what behavior we expect from the function under test. It should help you frame your mind so that when a test fails you can more easily figure out what broke. The name of your test should consist of three parts: The name of the method being tested. The scenario under which it's being tested. The expected behavior when the scenario is invoked. MethodUnderTest_Scenario_Behavior Samples: Add_SingleNumber_ReturnsSameNumber Add_MultipleNumbers_ReturnsSumOfNumbers Add_MaximumSumResult_ThrowsOverflowException Arranging your tests The AAA (Arrange, Act, Assert) pattern is a common way of writing unit tests for a method under test. The Arrange section of a unit test method initializes objects and sets the value of the data that is passed to the method under test. The Act section invokes the method under test with the arranged parameters. The Assert section verifies that the action of the method under test behaves as expected. Following this pattern does make the code quite well structured and easy to understand. In general lines, it would look like this: // arrange var repository = Substitute.For<IClientRepository>(); var client = new Client(repository); // act client.Save(); // assert mock.Received.SomeMethod(); Comments // can be skipped. Structure Basic Sources: /XToolkit.Common /Extensions StringExtensions.cs Tests: /XToolkit.Common.Tests /Extensions /StringExtensionsTests StringExtensionsTests.cs ... <-- any related classes Advanced Tests: /XToolkit.Common.Tests /Commands /AsyncCommandTests AsyncCommandTests.cs <-- class related tests AsyncCommandTestsCanExecute.cs <-- tests related to CanExecute() method AsyncCommandTestsExecute.cs <-- tests related to Execute() method Tools xUnit.Net - unit testing framework NSubstitute - mocking framework Resources Unit testing best practices with .NET Core and .NET Standard Book - The Art of Unit Testing"
  },
  "articles/xtoolkit/bindings.html": {
    "href": "articles/xtoolkit/bindings.html",
    "title": "XToolkit Bindings | XToolkit.WhiteLabel",
    "keywords": "XToolkit Bindings Implementation of Bindings based on MVVM Light Toolkit that supports .NET Standard and has a lot of functionality for collections. For more details see www.mvvmlight.net/doc Install When you use this component separately from WhiteLabel. You can install via NuGet: Install-Package Softeq.XToolkit.Bindings Getting Started Setup This section only when you use this component separately from WhiteLabel. To start using Bindings just add this code to your project: iOS in AppDelegate.cs public override bool FinishedLaunching(UIApplication application, NSDictionary launchOptions) { // init factory for bindings BindingExtensions.Initialize(new AppleBindingFactory()); ... return true; } Android in MainApplication.cs public abstract class MainApplicationBase : Application { ... public override void OnCreate() { base.OnCreate(); // init factory for bindings BindingExtensions.Initialize(new DroidBindingFactory()); ... } ... } More Advanced Bindings iOS & Android Collections"
  },
  "articles/xtoolkit/bindings/advanced.html": {
    "href": "articles/xtoolkit/bindings/advanced.html",
    "title": "Advanced Bindings | XToolkit.WhiteLabel",
    "keywords": "Advanced Bindings Bindings provide a powerful and simple approach to use MVVM in your applications. Bindings Bind - an extension method that provides for any views that implement the interface IBindingsOwner (more details: Bindable) XToolkit Bindings supports three types of bindings: OneTime, OneWay, TwoWay One-Way This binding mode transfers values from ViewModel to View; Whenever the property changes within the ViewModel, the corresponding View property is automatically adjusted; This binding mode is useful when showing, for example, data that is arriving from a dynamic source - like from a sensor or from a network data feed. One-way bindings used by default. this.Bind(() => ViewModel.FirstName, () => FirstNameLabel.Text); Two-Way This binding mode transfers values in both directions; Changes in both View and ViewModel properties are monitored - if either change, then the other will be updated; This binding mode is useful when editing entries in an existing form; Have some default definitions for simple platform controls, like Label, UISwitch, TextView, for other cases provides a mechanism for define custom bindings (look below). this.Bind(() => ViewModel.Count, () => CountField.Text, BindingMode.TwoWay); One-Time This binding mode transfers values from ViewModel to View; This transfer doesn’t actively monitor change messages/events from the ViewModel; Instead, this binding mode tries to transfer data from ViewModel to View only when the binding source is set. After this, the binding doesn’t monitor changes and doesn’t perform any updates, unless the binding source itself is reset; This mode is not very commonly used but can be useful for fields that are configurable but which don’t tend to change after they have initially been set. Extended Bind this.Bind(() => ViewModel.Count, count => CountField.Text = count, BindingMode.TwoWay); Value Converters A ValueConverter is a class that implements the IConverter<TOut, TIn> interface. IConverter<string, Person> _personConverter; this.Bind(() => ViewModel.Person, () => NameLabel.Text, _personConverter); Also, you can use ConverterBase<TOut, TIn> abstract class for common cases. ValueConverters can also be provided with a parameter - this can sometimes be useful to reuse a single value converter in different situations. Commands Add command for default controls (UIButton, Button, ...): OpenPageButton.SetCommand(ViewModel.OpenPageCommand); Add command for any EventHandler: linkSpan.SetCommand(nameof(linkSpan.Clicked), ViewModel.ClickHereCommand); Collections More details: iOS & Android Collections . . // TODO . . Rich examples Applying two-way binding for iOS native control: _datePicker = new UIDatePicker(CGRect.Empty); _formatter = new NSDateFormatter(); var binding = this.SetBinding( () => ViewModel.PaymentDate, () => _datePicker.Date, BindingMode.TwoWay) // converter from NSDate to string .ConvertTargetToSource(date => _formatter.ToString(date)) // observe custom event .ObserveTargetEvent(nameof(UIDatePicker.ValueChanged)));"
  },
  "articles/xtoolkit/bindings/bindable.html": {
    "href": "articles/xtoolkit/bindings/bindable.html",
    "title": "Bindable | XToolkit.WhiteLabel",
    "keywords": "Bindable IBindingsOwner - a common contract for everyone who wants to use bindings (and tasty extensions for them). IBindable - a contract for each Bindable View that provides a mechanism to control DataContext. DataContext - data context for an element when it participates in data binding. Data context is a concept that allows elements to inherit information from their parent elements about the data source that is used for binding, as well as other characteristics of the binding, such as the path. Each Bindable* view must provide a contract to add bindings safely, such as SetBinding() method. // TODO: Create custom View contains Bindings Need to implement IBindable interface. Basic: public class CustomView : AnyPlatformUIObject, IBindable { public CustomView() { Bindings = new List<Binding>(); } public object DataContext { get; set; } public List<Binding> Bindings { get; } public virtual void SetBindings() { // set your bindings here } } Add ViewModel property for typed DataContext: protected TViewModel ViewModel => (TViewModel) DataContext; Can be setup: var view = new CustomView<My>(); Add using: using Softeq.XToolkit.Bindings.Extensions; Use extention methods: view.SetDataContext(default(TViewModel));"
  },
  "articles/xtoolkit/bindings/collections.html": {
    "href": "articles/xtoolkit/bindings/collections.html",
    "title": "Collections | XToolkit.WhiteLabel",
    "keywords": "Collections iOS All Binbable* sources work with reusable cells, for that must be declared before use: Registering cell as reusable: Table\\CollectionView.RegisterNibForCellReuse(ItemViewCell.Nib, ItemViewCell.Key); Inherit BindableTableViewCell, BindableCollectionViewCell, BindableTableViewHeaderFooterView, BindableUICollectionReusableView or any custom cell with IBindableView interface. More samples about using those sources you can see in our Playground. UITableViewSource BindableTableViewSource<TItem, TItemCell> var source = new BindableTableViewSource<ItemViewModel, ItemViewCell>(ViewModel.Items); BindableTableViewSource<TKey, TItem, TGroupCell, TItemCell> var source = new BindableTableViewSource<HeaderViewModel, ItemViewModel, HeaderViewCell, ItemViewCell>(TableView, ViewModel.Items); UICollectionViewSource BindableCollectionViewSource<TItem, TCell> var source = new BindableCollectionViewSource<ItemViewModel, ItemViewCell>(ViewModel.Items); Android All Binbable* adapters work with reusable ViewHolders, for that must be declared before use: Inherit BindableViewHolder, or any custom ViewHolder with IBindableViewHolder interface. Add BindableViewHolderLayout attribute for auto-inflating ViewHolder layout. More samples about using those sources you can see in our Playground. BindableRecyclerViewAdapter<TViewModel, TViewHolder> var adapter = new BindableRecyclerViewAdapter<ItemViewModel, ItemViewHolder>(ViewModel.Items); BindableRecyclerViewAdapter<TKey, TItem, TItemHolder> var adapter = new BindableRecyclerViewAdapter<HeaderViewModel, ItemViewModel, ItemViewHolder>( items: ViewModel.Items, headerViewHolder: typeof(HeaderViewHolder));"
  },
  "articles/xtoolkit/common.html": {
    "href": "articles/xtoolkit/common.html",
    "title": "XToolkit Common | XToolkit.WhiteLabel",
    "keywords": "XToolkit Common The most common components without dependencies. Almost all projects can should use this library. Install When you use this component separately from WhiteLabel. You can install via NuGet: Install-Package Softeq.XToolkit.Common Description Common Collections Class Description ObservableRangeCollection Represents a dynamic data collection that provides notifications when items get added, removed, or when the whole list is refreshed. ObservableItemContentRangeCollection Additionally to notifications inherited from ObservableRangeCollection notifies when any of the items (INotifyPropertyChanged) is updated. ObservableKeyGroupsCollection Grouping of items by key into ObservableRange. BiDictionary Use this dictionary in case you need fast access to the key by value. Extensions Assembly DateTime Dictionary Enumerable Enum List Stream String Task Type Helpers StringsHelper TagsHelper TextRange WeakObjects Class Description WeakAction Stores an Action without causing a hard reference to be created to the Action's owner. The owner can be garbage collected at any time. WeakFunc Stores a Func without causing a hard reference to be created to the Func's owner. The owner can be garbage collected at any time. WeakEventSubscription Weak subscription for any event. Commands Class Description RelayCommand Implementation of ICommand interface. Used WeakAction and WeakFunc. AsyncCommand Implementation of ICommand interface. Allows Commands to safely be used asynchronously with Task. Other Class Description Timer Cross-platform Async timer. GenericEventArgs Generic EventArgs class. Common.iOS iOS Extensions DateTime - DateTime to NSDate and back converter UIColor UIImage UITextField UIView UIViewController Common.Droid BoolToViewStateConverter Droid Extensions Context EditText Intent String TextView View"
  },
  "articles/xtoolkit/connectivity.html": {
    "href": "articles/xtoolkit/connectivity.html",
    "title": "XToolkit Connectivity | XToolkit.WhiteLabel",
    "keywords": "XToolkit Connectivity Library over the Xam.Plugin.Connectivity with iOS 12+ native API support. Install Currently can be used only as source code (via git submodules). Setup Project Reference Add references to Softeq.XToolkit.Connectivity.* for projects where you need to use Connectivity component. Registration Use platform-specific boostrapper to register dependency on Connectivity component: Android builder.Singleton<ConnectivityService, IConnectivityService>(); iOS builder.Singleton<IosConnectivityService, IConnectivityService>(); Usage Please, use IConnectivityService to check and observe connection status. You can find some usage examples below: Check connection var isConnected = _connectivityService.IsConnected; Connection changed _connectivityService.ConnectivityChanged += (sender, args) => { var isConnected = args.IsConnected; }; Connection type changed _connectivityService.ConnectivityTypeChanged += (sender, args) => { var isConnected = args.IsConnected; var connectionTypes = args.ConnectionTypes; if (isConnected && connectionTypes.Contains(ConnectionType.WiFi)) { // WiFi connected } };"
  },
  "articles/xtoolkit/overview.html": {
    "href": "articles/xtoolkit/overview.html",
    "title": "XToolkit Components Overview | XToolkit.WhiteLabel",
    "keywords": "XToolkit Components Overview Library Description Supported platforms Softeq.XToolkit.Common The most common components without dependencies that can be reused in any project. Core, Android, iOS Softeq.XToolkit.Bindings Bindings implementation based on INotifyPropertyChanged interface (basic MVVMLight) with extends UI collections. Core, Android, iOS Softeq.XToolkit.Connectivity Library over the Xam.Plugin.Connectivity with support iOS 12+ native API. Core, iOS Softeq.XToolkit.Permissions Extended library over the Plugin.Permissions that covered the common cases of working with permissions. Core, Android, iOS Softeq.XToolkit.PushNotifications Rich implementation of common cases for push-notifications using APNs and Firebase Cloud Messaging. Core, Android, iOS Softeq.XToolkit.Remote Library provides a common way to make HTTP requests. Core Softeq.XToolkit.WhiteLabel MVVM framework (DI, Navigation, MVVM) that based on XToolkit components. Core, Android, iOS Softeq.XToolkit.WhiteLabel.Essentials Library over the XToolkit.WhiteLabel that contains optional components for any application (like ImagePicker). Core, Android, iOS Softeq.XToolkit.WhiteLabel.Forms (Deprecated) Integration library for using XToolkit.WhiteLabel in Xamarin.Forms projects. Core Additional Components Version Support"
  },
  "articles/xtoolkit/permissions.html": {
    "href": "articles/xtoolkit/permissions.html",
    "title": "XToolkit Permissions | XToolkit.WhiteLabel",
    "keywords": "XToolkit Permissions Extended library over the Xamarin.Essentials Permissions that covered common cases of working with permissions. Install When you use this component separately from WhiteLabel. You can install via NuGet: Install-Package Softeq.XToolkit.Permissions Setup Android Register dependencies in platform-specific Bootstrapper: // permissions builder.Singleton<PermissionsService, IPermissionsService>(); builder.Singleton<PermissionsManager, IPermissionsManager>(); builder.Singleton<RequestResultHandler, IPermissionRequestHandler>(); Add Handler IMPORTANT This section only for WhiteLabel.Forms.Droid project. WhiteLabel provides this functionality by default. Add registrations to MainActivity (Forms.Droid entry point): protected override void OnCreate(Bundle savedInstanceState) { base.OnCreate(savedInstanceState); // ... Xamarin.Essentials.Platform.Init(this, savedInstanceState); // ... } public override void OnRequestPermissionsResult( int requestCode, string[] permissions, [GeneratedEnum] Permission[] grantResults) { Dependencies.Container.Resolve<IPermissionRequestHandler>()?.Handle(requestCode, permissions, grantResults); base.OnRequestPermissionsResult(requestCode, permissions, grantResults); } iOS Register dependencies in platform-specific Bootstrapper: // permissions builder.Singleton<PermissionsService, IPermissionsService>(); builder.Singleton<PermissionsManager, IPermissionsManager>(); Declare permissions Don't forget to add permission declarations: iOS: Info.plist Android: AndroidManifest.xml Using Get IPermissionsManager from the constructor: public class NewPageViewModel : ViewModelBase { public NewPageViewModel(IPermissionsManager permissionsManager) { // ... } } Check Permission with Request await _permissionsManager.CheckWithRequestAsync<Xamarin.Essentials.Permissions.Camera>(); Check Permission Only await _permissionsManager.CheckAsync<Xamarin.Essentials.Permissions.Camera>(); Description Common Contracts Contract Implementation IPermissionsManager iOS, Android IPermissionsService iOS, Android IPermissionRequestHandler Android PermissionStatus Core Default Platform-Specific implementation Default implementation handles a set of predefined permissions (see below) and has additional behavior to request permissions and double-dialog check and opening application settings when the permissions are Denied. Default implementation depends on Xamarin.Essentials.Permissions About Xamarin.Essentials Permissions Available Permissions Custom Permissions"
  },
  "articles/xtoolkit/push-notifications.html": {
    "href": "articles/xtoolkit/push-notifications.html",
    "title": "XToolkit Push Notifications | XToolkit.WhiteLabel",
    "keywords": "XToolkit Push Notifications Rich implementation of common cases for push-notifications using APNs and Firebase Cloud Messaging. Install When you use this component separately from WhiteLabel. You can install via NuGet: Install-Package Softeq.XToolkit.PushNotifications Setup Core Add the following WhiteLabel projects to references: Softeq.XToolkit.PushNotifications Add implementation for IPushNotificationsHandler, do whatever you want in: HandlePushNotificationReceived HandlePushNotificationTapped HandleSilentPushNotification all of these methods receive PushNotificationModel. OnPushRegistrationCompleted has parameters showing if registration was completed in system and on server, you can handle it additionally if needed HandleInvalidPushNotification allows you to handle errors during notification parsing, it contains an Exception and a raw notification object OnPushPermissionsRequestCompleted is relevant for iOS platform only and allows you to analyze user reaction to notifications permission request (registration will be performed in any case) Use default implementation(PushTokenStorageService which uses IInternalSettings) or add your own implementation for IPushTokenStorageService which: implements PushToken getter and setter to store the token in internal settings, for instance implements storing IsTokenRegisteredInSystem and IsTokenSavedOnServer flags Add implementation for IRemotePushNotificationsService: implement methods to send push token to the server and remove it from server Register your implementations in Bootstrapper (IPushNotificationsHandler, IRemotePushNotificationsService), also register an implementation of ILogManager Register PushTokenStorageService or your implementation as IPushTokenStorageService in Bootstrapper; if you use default PushTokenStorageService then also register IInternalSettings implementation (possibly in platform projects) Optionally Add enum for push types and a method to convert string type to enum value Usage When you want to subscribe to notifications call IPushNotificationsService method RegisterForPushNotifications When you want to unsubscribe from notifications call IPushNotificationsService method UnregisterFromPushNotifications, with true parameter if you want to unsubscribe in system as well (default parameter value is false) When you want to clear notifications in notification center call IPushNotificationsService method ClearAllNotifications When you want to manually set a value for app badge call SetBadgeNumber with required value (NOTE: on Android https://github.com/wcoder/ShortcutBadger is used and not all devices are supported) iOS Add the following WhiteLabel projects to references: Softeq.XToolkit.PushNotifications Softeq.XToolkit.PushNotifications.iOS Perform standard setup: Add Provisioning profile with Push Notifications capability and pass APNs certificates to the server-side Add implementation for INotificationsPermissionsService: you can use default implementation IosNotificationsPermissionsService you can override IosNotificationsPermissionsService and provide custom authentication options as RequiredAuthOptions you can provide your own implementation of INotificationsPermissionsService with RequestNotificationsPermissions method using toolkit PermissionManager for instance If needed add custom subclass of IosPushNotificationParser where you can: specify custom key for additional data part of the notification (stored as a peer for apps) - you will be able to handle it as you wish later, default key is Data; specify custom way to obtain string type from notification, without it the type will always be an empty string, to do this you have the whole notification, the aps part and the additional data part If you want to register some categories for your notifications (with or without actions), add an implementation for INotificationCategoriesProvider. Default implementation IosNotificationCategoriesProvider does not contain any categories but provides helper methods for simplified actions and categories setup so you can override it to set up your categories. Register your implementations in Bootstrapper (INotificationsPermissionsService, IosPushNotificationParser or your custom subclass as IPushNotificationParser, IosNotificationCategoriesProvider if you do not need to work with categories or your custom subclass if you do need to specify some categories as INotificationCategoriesProvider) Register IosPushNotificationsService as IPushNotificationsService in Bootstrapper In your AppDelegate In FinishedLaunching method call IPushNotificationsService method Initialize with ForegroundNotificationOptions.ShowWithBadge value if you want to display foreground notifications in system notification center and update badge value from notification as well, ForegroundNotificationOptions.Show value if you want to display foreground notifications in system notification center but not to update badge value from notification, ForegroundNotificationOptions.DoNotShow if you do not want to display foreground notifications in system notification center Override RegisteredForRemoteNotifications method and call IPushNotificationsService method OnRegisteredForPushNotifications with deviceToken.AsString() Override FailedToRegisterForRemoteNotifications method and call IPushNotificationsService method OnFailedToRegisterForPushNotifications with error.Description If you want to receive silent push notifications override DidReceiveRemoteNotification(with completionHandler) method and call IPushNotificationsService method OnMessageReceived with userInfo and any value as second parameter. Do not forget to invoke completionHandler. (Make sure that aps in notification payload contains content-available:1 and does not contain alert, sound or badge keys) Additionally if needed (for silent push notifications) you can add to your Info.plist UIBackgroundModes remote-notification Android Add the following WhiteLabel projects to references: Softeq.XToolkit.PushNotifications Softeq.XToolkit.PushNotifications.Droid Perform standard Firebase setup Create application project in Firebase Console and pass Server Key to the server-side Add Xamarin.Firebase.Messaging to packages Add google-services.json to root Droid project with Build Action > GoogleServicesJson Add the following to your AndroidManifet.xml inside <application>: <receiver android:name=\"com.google.firebase.iid.FirebaseInstanceIdInternalReceiver\" android:exported=\"false\" /> <receiver android:name=\"com.google.firebase.iid.FirebaseInstanceIdReceiver\" android:exported=\"true\" android:permission=\"com.google.android.c2dm.permission.SEND\"> <intent-filter> <action android:name=\"com.google.android.c2dm.intent.RECEIVE\" /> <action android:name=\"com.google.android.c2dm.intent.REGISTRATION\" /> <category android:name=\"${applicationId}\" /> </intent-filter> </receiver> Optionally add also the following to specify icon and color: <meta-data android:name=\"com.google.firebase.messaging.default_notification_icon\" android:resource=\"@drawable/ic_notification\" /> <meta-data android:name=\"com.google.firebase.messaging.default_notification_color\" android:resource=\"@color/notification_color\" /> Add Mono.Android.Export to references (required to be able to identify if notifications are received in foreground) Add implementation for INotificationsSettingsProvider (they will be applied for manually shown notifications - all data 'notifications' and foreground 'notification' notifications): Provide a dictionary of Notification Channels ids and names for Android 8+, the importance for each channel id, the default channel id and a method that returns channel id for specific notification If needed provide additional configuration for each notification channel before it's registered (for instance, create and set a group) in ConfigureNotificationChannel Provide styles for manually shown notifications (return PushNotificationStyles object, where you have to specify NotificationCompat.Style and may customize other properties like an icon, etc.) If needed add more customization of notification (like adding actions) in CustomizeNotificationBuilder Provide the type of the Activity which will be opened after tapping on the notification that was shown manually and if parent stack needs to be created for it Additionally you can use helper methods from NotificationActionsHelper to work with actions and from NotificationChannelsHelper if you need to manage channel groups or notification channels that reflect user choices If needed add custom subclass of DroidPushNotificationParser where you can: specify custom key for additional data part of the notification (stored inside RemoteMessage.Data) - you will be able to handle it as you wish later, default key is Data; specify custom keys for title and body if you have them inside RemoteMessage.Data instead of RemoteMessage's Notification part specify custom way to obtain string type from notification, without it the type will always be an empty string, you will have to override two methods - one gives you IDictionary which is RemoteMessage.Data, the other gives you Bundle which stores everything that was in RemoteMessage.Data Register your implementations in Bootstrapper (INotificationsSettingsProvider, DroidPushNotificationParser or your custom subclass as IPushNotificationParser) Register DroidPushNotificationsService as IPushNotificationsService in Bootstrapper In your MainApplication in OnCreate method call IPushNotificationsService method Initialize with ForegroundNotificationOptions.Show value if you want to display foreground notifications in system notification center, ForegroundNotificationOptions.DoNotShow otherwise In your starting activity OnCreate check if Intent?.Extras are not null and contain push notifications data (you can check your custom data key for instance) and call IPushNotificationsService method OnMessageTapped(extras) in this case (might require a delay or passing forward and calling OnMessageTapped later)"
  },
  "articles/xtoolkit/remote.html": {
    "href": "articles/xtoolkit/remote.html",
    "title": "XToolkit Remote | XToolkit.WhiteLabel",
    "keywords": "XToolkit Remote Overview An opinionated HTTP library for Mobile Development. It provides a common way to make HTTP requests. It helps you to write more efficient code in mobile and desktop applications written in C#. Features HttpClient builder Cancellation Throwing exceptions (system exceptions preferred) Logger & diagnostic Retry Refit Auth with refresh token Layers HttpClientBuilder - create & configure HttpClient; ApiService - create API service implementation based on Refit or custom implementation; RemoteService - make service calls with retry & catch exceptions; Install When you use this component separately from WhiteLabel. You can install via NuGet: Install-Package Softeq.XToolkit.Remote Usage These are the steps to describe a simple way to make an HTTP request: Step 1 Firstly you need to create an interface for declaring API endpoints: public interface IApi { [Get(\"/profile\")] Task<string> GetProfile(CancellationToken ct); } Refit library is used for declaring the API endpoints. Step 2 Create simple HttpClient: var httpClient = new HttpClient { BaseAddress = new Uri(\"https://example.com/api\") }; The library provides an advanced way to create HttpClient. See DefaultHttpClientFactory, HttpClientBuilder. Step 3 Create instance of RemoteService: var remoteServiceFactory = new RemoteServiceFactory(); var remoteService = remoteServiceFactory.Create<IApi>(httpClient); In this case, it can be used in a simpler way: var remoteService = remoteServiceFactory.Create<IApi>(\"https://example.com/api\"); Step 4 Make simple request: var result = await remoteService.MakeRequest( (service, cancellationToken) => service.GetProfile(cancellationToken)); or safe call example: ILogger logger = ...; var result = await remoteService.SafeRequest( (service, cancellationToken) => service.GetProfile(cancellationToken), CancellationToken.None, // optional: parent token logger) Advanced Custom primary handler Declare custom primary handler: var customPrimaryHandler = new SocketsHttpHandler(); Use custom handler for HttpClientBuilder: var messageHandlerBuilder = new DefaultHttpMessageHandlerBuilder(customPrimaryHandler); var httpClientBuilder = new HttpClientBuilder(messageHandlerBuilder); var httpClient = httpClientBuilder .WithBaseUrl(\"https://softeq.com\") .Build(); Setup HttpClient HttpClient <- [DefaultHttpClientFactory] <- HttpClientBuilder <- [DefaultHttpMessageHandlerBuilder] <- HttpMessageHandler Enable logging Create HttpClient with pre-configure logging: Create any ILogger instance: ILogger logger = ...; via IHttpClientFactory: var httpClientFactory = new DefaultHttpClientFactory(); var httpClient = httpClientFactory.CreateClient(\"https://softeq.com\", logger); via HttpClientBuilder: var httpClient = new HttpClientBuilder() .WithBaseUrl(\"https://softeq.com\") .WithLogger(logger, LogVerbosity.All) .Build(); By default .WithLogger() will be use HttpDiagnosticsHandler. You can set the verbosity for all of your HttpDiagnosticsHandler instances by setting HttpDiagnosticsHandler.DefaultVerbosity. To set verbosity at the per-instance level, use HttpDiagnosticsHandler constructor which will override HttpDiagnosticsHandler.DefaultVerbosity. Use configured HttpClient: var remoteService = remoteServiceFactory.Create<IApi>(httpClient); Request options var options = new RequestOptions { Timeout = 5, RetryCount = 2 }; var result = await remoteService.MakeRequest( (s, ct) => s.GetProfile(ct), options); Examples Playground.Forms.Remote Softeq Auth sample POST forms Upload data Stream data deserialize FFImageLoading integration etc."
  },
  "articles/xtoolkit/version-support.html": {
    "href": "articles/xtoolkit/version-support.html",
    "title": "Version Support | XToolkit.WhiteLabel",
    "keywords": "Version Support Actual for the latest release: v2.0.0-beta10 Main Versions Android v5.0 (API level 21), target v12.0 (API level 32) iOS 12+ Components Versions Common .NET 6 Android - target v12 (API level 32) iOS 12+ Bindings .NET 6 Android - target v12 (API level 32) iOS 12+ Connectivity .NET 6 iOS 10+ Permissions .NET 6 Android - target v12 (API level 32) iOS 10+ Push Notifications .NET 6 Android - target v12 (API level 32) iOS 10+ Remote .NET 6 WhiteLabel .NET 6 Android - target v12 (API level 32) iOS 12+ WhiteLabel.Essentials .NET 6 Android - target v12 (API level 32) iOS 12+ Development environment Latest update in PR #513: macOS 12+ Xcode 14.2+ .NET SDK 6.0.402 (XToolkit) .NET SDK 7.0.103 (Playground)"
  },
  "articles/xtoolkit/whitelabel.html": {
    "href": "articles/xtoolkit/whitelabel.html",
    "title": "XToolkit WhiteLabel | XToolkit.WhiteLabel",
    "keywords": "XToolkit WhiteLabel WhiteLabel is a modular, cross-platform MVVM framework from \"lego\" components for fast create powerful cross-platform mobile applications with Xamarin, based on Softeq.XToolkit. It supports Xamarin.iOS, Xamarin.Android. The high-level features that WhiteLabel provides you with are: MVVM architecture pattern Navigation system Data Binding Platform specifics support Inversion of Control container and Dependency Injection Lots of functionalities for common cases Complete flexibility on the platform level Light and flexible what allowing to create modular applications Install You can install via NuGet: Install-Package Softeq.XToolkit.WhiteLabel Get Started Base for WhiteLabel.iOS WhiteLabel.Droid WhiteLabel.Essentials WhiteLabel.Forms (Deprecated)"
  },
  "articles/xtoolkit/whitelabel/bootstrapper.html": {
    "href": "articles/xtoolkit/whitelabel/bootstrapper.html",
    "title": "Bootstrapper | XToolkit.WhiteLabel",
    "keywords": "Bootstrapper Responsibility: Setup WhiteLabel Setup dependencies Description WhiteLabel Core has BootstrapperBase where declared DI container and setup WhiteLabel dependencies. WhiteLabel platforms have IosBootstrapperBase, DroidBootstrapperBase, FormsBootstrapper classes extended by BootstrapperBase where declared platform-specific dependencies. IosBootstrapperBase and DroidBootstrapperBase inheritance of BootstrapperWithViewModelLookup that provide ability for auto-registering ViewModels for each platform-specific view. Each application must use WhiteLabel platform-specific bootstrappers for extending. Playground project contains an actual demo. AssemblySource What is AssemblySource.Instance? This is the place that WhiteLabel looks for Views. You can add assemblies to AssemblySource any time during your application lifecycle to make them available to the framework, but there is also a special place to do it in the Bootstrapper. Simply override SelectAssemblies like this: protected override IList<Assembly> SelectAssemblies() { return base.SelectAssemblies() // base WL assembly .AddItem(GetType().Assembly); // app assembly } All you have to do is return a list of searchable assemblies. By default, the base class returns the WL platform base assembly. If you have multiple referenced assemblies that contain views, this is an extension point you need to remember. Also, if you are dynamically loading modules, you’ll need to make sure they get registered with your IoC container and the AssemblySource.Instance when they are loaded. Next Dependency Injection"
  },
  "articles/xtoolkit/whitelabel/di.html": {
    "href": "articles/xtoolkit/whitelabel/di.html",
    "title": "Dependency Injection | XToolkit.WhiteLabel",
    "keywords": "Dependency Injection WhiteLabel declares its abstraction over the DI implementation. DryIoc is used out of the box. Registration To register dependencies you should use IContainerBuilder. Sample: containerBuilder.Singleton<JsonSerializer, IJsonSerializer>(); When you register new instances of internal services, you need to use IfRegistered.Replace otherwise you will have runtime exception about duplication registration. Resolving To resolving registered dependencies you should use IContainer. Sample: container.Resolve<IJsonSerializer>(); Lazy Because WhiteLabel use DryIoc under the hood, our IContainer has the implicit ability for lazy, factory resolving (DryIoc doc, Autofac doc) container.Resolve<Lazy<IJsonSerializer>>(); ViewModel All ViewModels that registered and used with WhiteLabel can resolve dependency via the constructor. public class MyViewModel : ViewModelBase { public MyViewModel( Lazy<IJsonSerializer> serializer, IDataService dataService) { } }"
  },
  "articles/xtoolkit/whitelabel/droid.html": {
    "href": "articles/xtoolkit/whitelabel/droid.html",
    "title": "XToolkit WhiteLabel Droid | XToolkit.WhiteLabel",
    "keywords": "XToolkit WhiteLabel Droid Android platform support for WhiteLabel. Classes Class Name Links MainApplicationBase Configure DroidBootstrapperBase Details ActivityBase Configure Controls ColoredClickableSpan colorResourceId is screen background color Text color is the theme's accent color or android:textColorLink if this attribute is defined in the theme. For the TextView in which you want to set text with this Span you should also set textView.MovementMethod = LinkMovementMethod.Instance;"
  },
  "articles/xtoolkit/whitelabel/essentials.html": {
    "href": "articles/xtoolkit/whitelabel/essentials.html",
    "title": "XToolkit WhiteLabel Essentials | XToolkit.WhiteLabel",
    "keywords": "XToolkit WhiteLabel Essentials Library over the XToolkit.WhiteLabel that contains optional components for any application (like ImagePicker). Install You can install via NuGet: Install-Package Softeq.XToolkit.WhiteLabel.Essentials Components ImagePicker"
  },
  "articles/xtoolkit/whitelabel/forms.html": {
    "href": "articles/xtoolkit/whitelabel/forms.html",
    "title": "XToolkit WhiteLabel Forms | XToolkit.WhiteLabel",
    "keywords": "XToolkit WhiteLabel Forms Integration library for using WhiteLabel in Xamarin.Forms projects. Important This package is not supported anymore. The main reason is Xamarin.Forms End of Support. Install You can install via NuGet: Install-Package Softeq.XToolkit.WhiteLabel.Forms Get Started TODO See Playground.Forms Classes FormsApp FormsBootstrapper - more details about Bootstrapper"
  },
  "articles/xtoolkit/whitelabel/ios.html": {
    "href": "articles/xtoolkit/whitelabel/ios.html",
    "title": "XToolkit WhiteLabel iOS | XToolkit.WhiteLabel",
    "keywords": "XToolkit WhiteLabel iOS iOS platform support for WhiteLabel. Classes Class Name Links AppDelegateBase Configure IosBootstrapperBase Details ViewControllerBase Configure Controls Class Name Links CustomViewBase How to create"
  },
  "articles/xtoolkit/whitelabel/mvvm.html": {
    "href": "articles/xtoolkit/whitelabel/mvvm.html",
    "title": "MVVM | XToolkit.WhiteLabel",
    "keywords": "MVVM XToolkit.WhiteLabel is a framework based on the Model-View-ViewModel (MVVM) pattern. WhiteLabel helps you to separate your View from your Model which creates applications that are cleaner and easier to maintain and extend. It also creates testable applications and allows you to have a much thinner user interface layer (which is more difficult to test automatically). XToolkit.WhiteLabel is intended to be a fully-featured MVVM Framework and does include some features like ViewModel-first navigation, DI, and messaging. XToolkit.Common can serve as a basis for developers who want to create their own MVVM implementation. By providing only the most basic of extra functionality but still following common conventions it should be the easiest option. Core files ObservableObject ObservableObject contains an implementation of the INotifyPropertyChanged interface and is used as a base class for all ViewModels. This makes it easy to update bound properties on the View. ViewModelBase ViewModelBase is the base class for all page view-models in the application. Commands RelayCommand/AsyncCommand contains an implementation of the ICommand interface and allows the View to call commands on the ViewModel, rather than handle UI events directly. Navigation XToolkit.WhiteLabel assumes View-based navigation. This means that a ViewModel will trigger navigation to another View. You can learn more about Navigation here. Snippets Basic property private bool _isBusy; public bool IsBusy { get => _isBusy; private set => Set(ref _isBusy, value); } Constructor Init the command via constructor: // ctor { StartCommand = new AsyncCommand(StartAsync); } public IAsyncCommand StartCommand { get; } Lazy Lazy initialization of the command: private AsyncCommand _startCommand; public IAsyncCommand StartCommand => _startCommand ??= new AsyncCommand(StartAsync);"
  },
  "articles/xtoolkit/whitelabel/navigation-requirements.html": {
    "href": "articles/xtoolkit/whitelabel/navigation-requirements.html",
    "title": "Navigation Requirements | XToolkit.WhiteLabel",
    "keywords": "Navigation Requirements WhiteLabel internal ViewLocators require some rules for correct registration of ViewModel-UIPage navigation, you should follow some rules: Core Every page ViewModels should have: ViewModels namespace; {NAME}ViewModel class name; ViewModelBase inherit. Android Every Activity/Fragment should have: Droid.Views namespace; {NAME}Activity or {NAME}Fragment; ActivityBase<T> or FragmentBase<T> inherit. iOS Every ViewController should have: iOS.ViewControllers namespace; {NAME}ViewController class name; ViewControllerBase<T> inherit; {NAME}Storyboard storyboard name (only when ViewController has Storyboard). Auto-registration ViewModels Add all assemblies with UI pages to the SelectAssemblies (per-platform); Every UI page should meet the requirements above. UI Page - UI platform-specific page definition like Activity, Fragment, ViewController."
  },
  "articles/xtoolkit/whitelabel/navigation.html": {
    "href": "articles/xtoolkit/whitelabel/navigation.html",
    "title": "WhiteLabel Navigation | XToolkit.WhiteLabel",
    "keywords": "WhiteLabel Navigation To navigate from ViewModel to ViewModel you can use the following code: Navigation Simple Navigation var _pageNavigationService = new PageNavigationService(viewLocator, jsonSerializer); _pageNavigationService .For<MainPageViewModel>() .Navigate(); Navigation with parameter _pageNavigationService .For<MainPageViewModel>() .WithParam(x => x.ParameterName, parameterValue) .Navigate(shouldClearBackstack); Navigation with several parameters _pageNavigationService .For<MainPageViewModel>() .WithParam(x => x.Name, \"Sherlock Holmes\") .WithParam(x => x.Age, 25) .WithParam(x => x.Gender, null) .Navigate(shouldClearBackstack); IMPORTANT Use only simple models as parameters, because they can be de/serialized."
  },
  "articles/xtoolkit/whitelabel/validation.html": {
    "href": "articles/xtoolkit/whitelabel/validation.html",
    "title": "Validation | XToolkit.WhiteLabel",
    "keywords": "Validation In the context of the Model-ViewModel-Model (MVVM) pattern, a view model or model will often be required to perform data validation and signal any validation errors to the view so that the user can correct them. The following diagram shows the classes involved in performing validation in the WhiteLabel: View model properties that require validation are of type ValidatableObject, and each ValidatableObject instance has validation rules added to its Validations property. Validation is invoked from the view model by calling the Validate method of the ValidatableObject instance, which retrieves the validation rules and executes them against the ValidatableObject Value property. Any validation errors are placed into the Errors property of the ValidatableObject instance, and the IsValid property of the ValidatableObject instance is updated to indicate whether validation succeeded or failed. Property Create property public ValidatableObject<string> UserName { get; } //... UserName = new ValidatableObject<string>(); Adding Validation Rules var rule = new StringNotEmptyRule(\"A username is required.\"); UserName.AddRule(rule); This method adds the StringNotEmptyRule validation rule to the ValidatableObject instance, including a value for the ValidationMessage property, which specifies the validation error message that will be displayed if validation fails. Specifying Validation Rules Validation rules are specified by creating a class that derives from the IValidationRule interface. Triggering Validation Validation can be triggered manually for a view model property. private bool ValidateUserName() { return UserName.Validate(); } Groups Also, you can group several ValidatableObject instances to the ValidatableGroup: var validatableGroup = new ValidatableGroup(UserName, Email); Now you can validate all of these properties: var isValid = validatableGroup.Validate(); Integrations FluentValidation Basic integration can be implemented via creating custom rule: public abstract class FluentValidatorRule<T> : AbstractValidator<ValidationModel<T>>, IValidationRule<T> { private readonly ValidationModel<T> _model; protected FluentValidatorRule() { _model = new ValidationModel<T>(); InitValidator(); } public string ValidationMessage { get; private set; } = string.Empty; public bool Check(T value) { _model.Value = value; var result = Validate(_model); ValidationMessage = FormatResult(result); return result.IsValid; } private void InitValidator() { BuildRule(RuleFor(x => x.Value)); } protected abstract void BuildRule(IRuleBuilderInitial<ValidationModel<T>, T> ruleBuilder); protected virtual string FormatResult(ValidationResult result) { return result.ToString(\"~\"); } } // Wrapper over the value for FluentValidator public class ValidationModel<T> { public T Value { get; set; } } Now you can create a rule for your property: public class CustomEmailRule : FluentValidatorRule<string> { protected override void BuildRule(IRuleBuilderInitial<ValidationModel<string>, string> ruleBuilder) { ruleBuilder .NotEmpty().WithMessage(\"empty\") .EmailAddress().WithMessage(\"invalid email\"); } } For massive forms, this integration approach can be overhead, in this case, you can extend ValidatableObject or create a custom implementation. More info This approach was reworked, based on MS: Validation in Enterprise Apps"
  },
  "index.html": {
    "href": "index.html",
    "title": "XToolkit.WhiteLabel | XToolkit.WhiteLabel",
    "keywords": "XToolkit.WhiteLabel Build clean, pixel perfect, native UIs. Share behavior and business logic in a single codebase across supported platforms, using the Model-View-ViewModel (MVVM) design pattern. XToolkit is a set of components specifically designed for Xamarin and the mobile ecosystem. It supports: Xamarin.iOS/.NET for iOS Xamarin.Android/.NET for Android Get Started All Softeq.XToolkit components"
  }
}